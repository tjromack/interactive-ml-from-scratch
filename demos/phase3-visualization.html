<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase 3: Advanced ML Visualizations</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 50%, #2d1b69 100%);
            color: white;
            min-height: 100vh;
        }
        .header {
            text-align: center;
            margin-bottom: 40px;
        }
        .header h1 {
            font-size: 3em;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        .tab-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            gap: 10px;
        }
        .tab {
            padding: 15px 25px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        .tab:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        .tab.active {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            box-shadow: 0 5px 20px rgba(255,107,107,0.3);
        }
        .content-panel {
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            display: none;
        }
        .content-panel.active {
            display: block;
        }
        .controls {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        .controls button {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,107,107,0.3);
        }
        .controls button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .slider-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255,255,255,0.1);
            padding: 10px 15px;
            border-radius: 10px;
        }
        .slider-control input[type="range"] {
            width: 150px;
        }
        .plot-container {
            height: 500px;
            margin: 20px 0;
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            padding: 10px;
        }
        .plot-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        @media (max-width: 768px) {
            .plot-grid {
                grid-template-columns: 1fr;
            }
        }
        .explanation-box {
            background: rgba(76, 175, 80, 0.1);
            border-left: 4px solid #4caf50;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        .math-formula {
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 15px 0;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .insight-panel {
            background: rgba(255,193,7,0.1);
            border-left: 4px solid #ffc107;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Phase 3: Advanced ML Visualizations</h1>
        <p style="font-size: 1.2em; opacity: 0.8;">Making Machine Learning Intuitive Through Interactive Exploration</p>
    </div>

    <div class="tab-container">
        <button class="tab active" onclick="showTab('cost-surface')">3D Cost Surface</button>
        <button class="tab" onclick="showTab('gradient-flow')">Gradient Flow</button>
        <button class="tab" onclick="showTab('learning-dynamics')">Learning Dynamics</button>
        <button class="tab" onclick="showTab('interactive-demo')">Interactive Demo</button>
    </div>

    <!-- 3D Cost Surface Tab -->
    <div id="cost-surface" class="content-panel active">
        <h2>3D Cost Surface Exploration</h2>
        <div class="explanation-box">
            <h3>What you're seeing:</h3>
            <p><strong>The Cost Landscape:</strong> This 3D surface shows how the cost function varies with different parameter values (θ₀, θ₁). The lowest point represents the optimal parameters our algorithm seeks.</p>
            <p><strong>The Path:</strong> The red line shows the actual path gradient descent takes from initialization to convergence. Notice how it follows the steepest descent down the surface.</p>
        </div>
        
        <div class="controls">
            <button onclick="generateCostSurface()">Generate Cost Surface</button>
            <button onclick="showGradientPath()">Show Gradient Path</button>
            <button onclick="animateGradientDescent()">Animate Descent</button>
            <div class="slider-control">
                <label>Resolution:</label>
                <input type="range" id="resolutionSlider" min="20" max="100" value="50" onchange="updateResolution()">
                <span id="resolutionValue">50</span>
            </div>
        </div>

        <div id="costSurfacePlot" class="plot-container"></div>

        <div class="math-formula">
            Cost Function: J(θ₀, θ₁) = (1/2m) × Σ(θ₀ + θ₁×xᵢ - yᵢ)²
        </div>

        <div class="insight-panel">
            <h3>Key Insights:</h3>
            <ul>
                <li><strong>Convex Surface:</strong> Linear regression has a bowl-shaped cost function with one global minimum</li>
                <li><strong>Gradient Direction:</strong> At any point, the gradient points in the direction of steepest increase</li>
                <li><strong>Learning Rate Effect:</strong> Larger steps may overshoot; smaller steps converge slowly</li>
            </ul>
        </div>
    </div>

    <!-- Gradient Flow Tab -->
    <div id="gradient-flow" class="content-panel">
        <h2>Gradient Flow Visualization</h2>
        <div class="explanation-box">
            <h3>Understanding Gradient Vectors:</h3>
            <p><strong>Vector Field:</strong> Each arrow shows the direction and magnitude of the gradient at that point. The algorithm follows these arrows "downhill" toward the minimum.</p>
            <p><strong>Contour Lines:</strong> Show lines of equal cost - like elevation lines on a topographic map.</p>
        </div>
        
        <div class="controls">
            <button onclick="generateGradientField()">Generate Gradient Field</button>
            <button onclick="addContourLines()">Add Contour Lines</button>
            <button onclick="simulateMultipleStartingPoints()">Multiple Starting Points</button>
        </div>

        <div id="gradientFieldPlot" class="plot-container"></div>

        <div class="math-formula">
            Gradient: ∇J = [∂J/∂θ₀, ∂J/∂θ₁] = [(1/m)Σ(ĥ(xᵢ)-yᵢ), (1/m)Σ(ĥ(xᵢ)-yᵢ)×xᵢ]
        </div>
    </div>

    <!-- Learning Dynamics Tab -->
    <div id="learning-dynamics" class="content-panel">
        <h2>Learning Rate Dynamics</h2>
        <div class="explanation-box">
            <h3>How Learning Rate Affects Convergence:</h3>
            <p><strong>Too Small:</strong> Slow convergence, many iterations needed</p>
            <p><strong>Just Right:</strong> Efficient convergence in reasonable time</p>
            <p><strong>Too Large:</strong> Oscillation or divergence, may never converge</p>
        </div>
        
        <div class="controls">
            <button onclick="compareLearningRates()">Compare Learning Rates</button>
            <div class="slider-control">
                <label>Learning Rate:</label>
                <input type="range" id="learningRateSlider" min="0.001" max="1.0" step="0.001" value="0.1" onchange="updateLearningRate()">
                <span id="learningRateValue">0.1</span>
            </div>
            <button onclick="demonstrateOvershoot()">Show Overshoot</button>
        </div>

        <div class="plot-grid">
            <div id="learningComparisonPlot" class="plot-container"></div>
            <div id="parameterEvolutionPlot" class="plot-container"></div>
        </div>
    </div>

    <!-- Interactive Demo Tab -->
    <div id="interactive-demo" class="content-panel">
        <h2>Interactive Gradient Descent</h2>
        <div class="explanation-box">
            <h3>Explore the Algorithm Yourself:</h3>
            <p>Click anywhere on the cost surface to start gradient descent from that point. Adjust parameters and see immediate results.</p>
        </div>
        
        <div class="controls">
            <button onclick="enableInteractiveMode()">Enable Click-to-Start</button>
            <div class="slider-control">
                <label>Step Size:</label>
                <input type="range" id="stepSizeSlider" min="0.01" max="0.5" step="0.01" value="0.1" onchange="updateStepSize()">
                <span id="stepSizeValue">0.1</span>
            </div>
            <div class="slider-control">
                <label>Animation Speed:</label>
                <input type="range" id="speedSlider" min="1" max="10" value="5" onchange="updateSpeed()">
                <span id="speedValue">5</span>
            </div>
            <button onclick="resetDemo()">Reset</button>
        </div>

        <div id="interactivePlot" class="plot-container"></div>

        <div class="insight-panel">
            <h3>Try This:</h3>
            <ul>
                <li>Start from different points and observe how all paths lead to the same minimum</li>
                <li>Increase step size to see oscillation around the minimum</li>
                <li>Compare paths from points far from vs. close to the optimum</li>
            </ul>
        </div>
    </div>

    <script>
        // Global variables for our Phase 3 implementation
        let costSurfaceData = null;
        let gradientPathData = null;
        let isInteractiveMode = false;
        let animationSpeed = 5;
        
        // Use our working data from Phase 2
        const houseData = generateHouseDataForVisualization();
        
        function generateHouseDataForVisualization() {
            const TRUE_SLOPE = 150;
            const TRUE_INTERCEPT = 50000;
            const NOISE_LEVEL = 15000;
            const N_SAMPLES = 100;

            const data = {
                sqft: [],
                prices: [],
                trueSlope: TRUE_SLOPE,
                trueIntercept: TRUE_INTERCEPT
            };

            let seed = 42;
            function random() {
                const x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            }

            function normalRandom() {
                const u1 = random();
                const u2 = random();
                return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            }

            for (let i = 0; i < N_SAMPLES; i++) {
                const sqft = 800 + random() * (3000 - 800);
                const truePrice = TRUE_SLOPE * sqft + TRUE_INTERCEPT;
                const noise = normalRandom() * NOISE_LEVEL;
                
                data.sqft.push(sqft);
                data.prices.push(truePrice + noise);
            }

            return data;
        }

        // Tab switching functionality
        function showTab(tabName) {
            // Hide all panels
            document.querySelectorAll('.content-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected panel
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }

        // Cost surface calculation
        function calculateCostSurface(theta0Range, theta1Range, resolution) {
            const theta0Values = [];
            const theta1Values = [];
            const costValues = [];
            
            const theta0Min = theta0Range[0];
            const theta0Max = theta0Range[1];
            const theta1Min = theta1Range[0];
            const theta1Max = theta1Range[1];
            
            const step0 = (theta0Max - theta0Min) / (resolution - 1);
            const step1 = (theta1Max - theta1Min) / (resolution - 1);
            
            for (let i = 0; i < resolution; i++) {
                theta0Values.push(theta0Min + i * step0);
            }
            
            for (let j = 0; j < resolution; j++) {
                theta1Values.push(theta1Min + j * step1);
            }
            
            // Calculate cost for each parameter combination
            for (let i = 0; i < resolution; i++) {
                const row = [];
                for (let j = 0; j < resolution; j++) {
                    const theta0 = theta0Values[i];
                    const theta1 = theta1Values[j];
                    
                    // Calculate cost using our house data
                    let sumSquaredErrors = 0;
                    for (let k = 0; k < houseData.sqft.length; k++) {
                        const prediction = theta0 + theta1 * houseData.sqft[k];
                        const error = prediction - houseData.prices[k];
                        sumSquaredErrors += error * error;
                    }
                    
                    const cost = sumSquaredErrors / (2 * houseData.sqft.length);
                    row.push(cost);
                }
                costValues.push(row);
            }
            
            return {
                theta0: theta0Values,
                theta1: theta1Values,
                cost: costValues
            };
        }

        // Generate and display 3D cost surface
        function generateCostSurface() {
            console.log('Generating 3D cost surface...');
            
            const resolution = parseInt(document.getElementById('resolutionSlider').value);
            
            // Define parameter ranges around the true values
            const theta0Range = [30000, 70000]; // Around true intercept of 50000
            const theta1Range = [100, 200];     // Around true slope of 150
            
            costSurfaceData = calculateCostSurface(theta0Range, theta1Range, resolution);
            
            const surfaceTrace = {
                x: costSurfaceData.theta0,
                y: costSurfaceData.theta1,
                z: costSurfaceData.cost,
                type: 'surface',
                colorscale: [
                    [0, '#000428'],      // Deep blue (low cost)
                    [0.2, '#004e92'],    // Blue
                    [0.4, '#009ffd'],    // Light blue
                    [0.6, '#00d2ff'],    // Cyan
                    [0.8, '#ffa400'],    // Orange
                    [1, '#ff0000']       // Red (high cost)
                ],
                contours: {
                    z: {
                        show: true,
                        usecolormap: true,
                        highlightcolor: "#42f462",
                        project: {z: true}
                    }
                },
                name: 'Cost Surface'
            };
            
            const layout = {
                title: '3D Cost Function Surface',
                scene: {
                    xaxis: {title: 'θ₀ (Intercept)', color: 'white'},
                    yaxis: {title: 'θ₁ (Slope)', color: 'white'},
                    zaxis: {title: 'Cost J(θ₀, θ₁)', color: 'white'},
                    bgcolor: 'rgba(0,0,0,0)',
                    camera: {
                        eye: {x: 1.5, y: 1.5, z: 1.5}
                    }
                },
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: {color: 'white'}
            };
            
            Plotly.newPlot('costSurfacePlot', [surfaceTrace], layout);
            
            console.log('3D cost surface generated successfully');
        }

        // Show gradient descent path on the surface
        function showGradientPath() {
            if (!costSurfaceData) {
                alert('Please generate cost surface first!');
                return;
            }
            
            console.log('Calculating gradient descent path...');
            
            // Simulate gradient descent path
            const path = simulateGradientDescentPath();
            
            const pathTrace = {
                x: path.theta0,
                y: path.theta1,
                z: path.cost,
                type: 'scatter3d',
                mode: 'lines+markers',
                line: {
                    color: '#ff0000',
                    width: 8
                },
                marker: {
                    size: 4,
                    color: '#ff0000'
                },
                name: 'Gradient Descent Path'
            };
            
            Plotly.addTraces('costSurfacePlot', [pathTrace]);
            
            console.log('Gradient descent path added to surface');
        }

        // Simulate gradient descent path for visualization
        function simulateGradientDescentPath() {
            const learningRate = 0.000001; // Small rate for visualization
            const maxIterations = 1000;
            
            // Start from a point away from optimum
            let theta0 = 60000;
            let theta1 = 80;
            
            const path = {
                theta0: [theta0],
                theta1: [theta1],
                cost: []
            };
            
            // Calculate initial cost
            let cost = calculateCostAtPoint(theta0, theta1);
            path.cost.push(cost);
            
            for (let i = 0; i < maxIterations; i++) {
                // Calculate gradients
                const gradients = calculateGradients(theta0, theta1);
                
                // Update parameters
                theta0 -= learningRate * gradients.dTheta0;
                theta1 -= learningRate * gradients.dTheta1;
                
                // Calculate new cost
                cost = calculateCostAtPoint(theta0, theta1);
                
                // Store path
                path.theta0.push(theta0);
                path.theta1.push(theta1);
                path.cost.push(cost);
                
                // Check convergence
                if (i > 10) {
                    const recentCosts = path.cost.slice(-10);
                    const avgChange = recentCosts.reduce((sum, c, idx) => {
                        if (idx === 0) return 0;
                        return sum + Math.abs(c - recentCosts[idx-1]);
                    }, 0) / 9;
                    
                    if (avgChange < cost * 0.001) {
                        console.log(`Path converged after ${i} iterations`);
                        break;
                    }
                }
            }
            
            return path;
        }

        // Calculate cost at a specific point
        function calculateCostAtPoint(theta0, theta1) {
            let sumSquaredErrors = 0;
            for (let i = 0; i < houseData.sqft.length; i++) {
                const prediction = theta0 + theta1 * houseData.sqft[i];
                const error = prediction - houseData.prices[i];
                sumSquaredErrors += error * error;
            }
            return sumSquaredErrors / (2 * houseData.sqft.length);
        }

        // Calculate gradients at a specific point
        function calculateGradients(theta0, theta1) {
            const m = houseData.sqft.length;
            let sumErrors = 0;
            let sumErrorsTimesX = 0;
            
            for (let i = 0; i < m; i++) {
                const prediction = theta0 + theta1 * houseData.sqft[i];
                const error = prediction - houseData.prices[i];
                sumErrors += error;
                sumErrorsTimesX += error * houseData.sqft[i];
            }
            
            return {
                dTheta0: sumErrors / m,
                dTheta1: sumErrorsTimesX / m
            };
        }

        // Animate gradient descent
        async function animateGradientDescent() {
            if (!costSurfaceData) {
                alert('Please generate cost surface first!');
                return;
            }
            
            console.log('Starting gradient descent animation...');
            
            // Clear any existing animation traces
            const currentData = document.getElementById('costSurfacePlot').data;
            const surfaceTrace = currentData.find(trace => trace.name === 'Cost Surface');
            Plotly.react('costSurfacePlot', [surfaceTrace], document.getElementById('costSurfacePlot').layout);
            
            // Simulate gradient descent path step by step
            const learningRate = 0.000001;
            const maxIterations = 200; // Fewer steps for smooth animation
            
            let theta0 = 60000;
            let theta1 = 80;
            
            const pathPoints = {
                theta0: [theta0],
                theta1: [theta1],
                cost: [calculateCostAtPoint(theta0, theta1)]
            };
            
            // Animate each step
            for (let i = 0; i < maxIterations; i++) {
                // Calculate gradients
                const gradients = calculateGradients(theta0, theta1);
                
                // Update parameters
                theta0 -= learningRate * gradients.dTheta0;
                theta1 -= learningRate * gradients.dTheta1;
                
                // Calculate new cost
                const cost = calculateCostAtPoint(theta0, theta1);
                
                // Add to path
                pathPoints.theta0.push(theta0);
                pathPoints.theta1.push(theta1);
                pathPoints.cost.push(cost);
                
                // Update plot every few steps
                if (i % 5 === 0) {
                    const animationTrace = {
                        x: pathPoints.theta0,
                        y: pathPoints.theta1,
                        z: pathPoints.cost,
                        type: 'scatter3d',
                        mode: 'lines+markers',
                        line: {
                            color: '#ff0000',
                            width: 8
                        },
                        marker: {
                            size: 4,
                            color: '#ff0000'
                        },
                        name: 'Gradient Descent Path'
                    };
                    
                    Plotly.react('costSurfacePlot', [surfaceTrace, animationTrace], document.getElementById('costSurfacePlot').layout);
                    await new Promise(resolve => setTimeout(resolve, 100)); // Animation delay
                }
                
                // Check convergence
                if (i > 10) {
                    const recentCosts = pathPoints.cost.slice(-5);
                    const avgChange = recentCosts.reduce((sum, c, idx) => {
                        if (idx === 0) return 0;
                        return sum + Math.abs(c - recentCosts[idx-1]);
                    }, 0) / 4;
                    
                    if (avgChange < cost * 0.001) {
                        console.log(`Animation converged after ${i} steps`);
                        break;
                    }
                }
            }
            
            console.log('Gradient descent animation complete');
        }

        // Update resolution
        function updateResolution() {
            const value = document.getElementById('resolutionSlider').value;
            document.getElementById('resolutionValue').textContent = value;
        }

        // Generate gradient field visualization
        function generateGradientField() {
            console.log('Generating gradient field...');
            
            // Define parameter ranges for the field
            const theta0Range = [35000, 65000];
            const theta1Range = [100, 200];
            const gridSize = 15; // 15x15 grid of vectors
            
            const theta0Step = (theta0Range[1] - theta0Range[0]) / (gridSize - 1);
            const theta1Step = (theta1Range[1] - theta1Range[0]) / (gridSize - 1);
            
            const traces = [];
            
            // Calculate gradient vectors at each grid point and create individual arrow traces
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const theta0 = theta0Range[0] + i * theta0Step;
                    const theta1 = theta1Range[0] + j * theta1Step;
                    
                    const gradients = calculateGradients(theta0, theta1);
                    
                    // Scale the gradients for visualization
                    const scale = 1000; // Adjust this to make arrows visible
                    const arrowLength0 = -gradients.dTheta0 / scale;
                    const arrowLength1 = -gradients.dTheta1 / scale;
                    
                    // Create arrow using line traces with annotations
                    const arrowTrace = {
                        x: [theta0, theta0 + arrowLength0],
                        y: [theta1, theta1 + arrowLength1],
                        type: 'scatter',
                        mode: 'lines',
                        line: {
                            color: '#00ff00',
                            width: 2
                        },
                        showlegend: false,
                        hoverinfo: 'none'
                    };
                    
                    traces.push(arrowTrace);
                    
                    // Add arrowhead using a marker
                    const arrowHead = {
                        x: [theta0 + arrowLength0],
                        y: [theta1 + arrowLength1],
                        type: 'scatter',
                        mode: 'markers',
                        marker: {
                            symbol: 'triangle-up',
                            size: 6,
                            color: '#00ff00',
                            angle: Math.atan2(arrowLength1, arrowLength0) * 180 / Math.PI
                        },
                        showlegend: false,
                        hoverinfo: 'text',
                        text: `Gradient: [${gradients.dTheta0.toFixed(0)}, ${gradients.dTheta1.toFixed(2)}]`
                    };
                    
                    traces.push(arrowHead);
                }
            }
            
            // Add a legend trace
            const legendTrace = {
                x: [theta0Range[0]],
                y: [theta1Range[0]],
                type: 'scatter',
                mode: 'lines',
                line: {
                    color: '#00ff00',
                    width: 2
                },
                name: 'Gradient Vectors (Descent Direction)'
            };
            
            traces.push(legendTrace);
            
            const layout = {
                title: 'Gradient Vector Field - Arrows Point Toward Steepest Descent',
                xaxis: {title: 'θ₀ (Intercept)', color: 'white'},
                yaxis: {title: 'θ₁ (Slope)', color: 'white'},
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: {color: 'white'},
                legend: {
                    bgcolor: 'rgba(0,0,0,0.5)'
                }
            };
            
            Plotly.newPlot('gradientFieldPlot', traces, layout);
            
            console.log('Gradient field generated successfully');
        }

        // Add contour lines to gradient field
        function addContourLines() {
            console.log('Adding contour lines...');
            
            if (!document.getElementById('gradientFieldPlot').data.length) {
                alert('Please generate gradient field first!');
                return;
            }
            
            // Calculate contour data
            const resolution = 50;
            const theta0Range = [35000, 65000];
            const theta1Range = [100, 200];
            
            const contourData = calculateCostSurface(theta0Range, theta1Range, resolution);
            
            const contourTrace = {
                x: contourData.theta0,
                y: contourData.theta1,
                z: contourData.cost,
                type: 'contour',
                colorscale: 'Blues',
                opacity: 0.6,
                contours: {
                    showlabels: true,
                    labelfont: {color: 'white'}
                },
                name: 'Cost Contours'
            };
            
            Plotly.addTraces('gradientFieldPlot', [contourTrace]);
            
            console.log('Contour lines added');
        }

        // Simulate multiple starting points
        function simulateMultipleStartingPoints() {
            console.log('Simulating multiple starting points...');
            
            if (!document.getElementById('gradientFieldPlot').data.length) {
                alert('Please generate gradient field first!');
                return;
            }
            
            // Define different starting points
            const startingPoints = [
                {theta0: 40000, theta1: 120},
                {theta0: 60000, theta1: 180},
                {theta0: 45000, theta1: 160},
                {theta0: 55000, theta1: 110}
            ];
            
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00'];
            
            startingPoints.forEach((start, index) => {
                const path = simulateGradientDescentFrom(start.theta0, start.theta1);
                
                const pathTrace = {
                    x: path.theta0,
                    y: path.theta1,
                    type: 'scatter',
                    mode: 'lines+markers',
                    line: {
                        color: colors[index],
                        width: 3
                    },
                    marker: {
                        size: 6,
                        color: colors[index]
                    },
                    name: `Path ${index + 1}`
                };
                
                Plotly.addTraces('gradientFieldPlot', [pathTrace]);
            });
            
            console.log('Multiple starting points simulated');
        }

        // Simulate gradient descent from a specific starting point (2D version)
        function simulateGradientDescentFrom(startTheta0, startTheta1) {
            const learningRate = 0.000001;
            const maxIterations = 500;
            
            let theta0 = startTheta0;
            let theta1 = startTheta1;
            
            const path = {
                theta0: [theta0],
                theta1: [theta1]
            };
            
            for (let i = 0; i < maxIterations; i++) {
                const gradients = calculateGradients(theta0, theta1);
                
                theta0 -= learningRate * gradients.dTheta0;
                theta1 -= learningRate * gradients.dTheta1;
                
                path.theta0.push(theta0);
                path.theta1.push(theta1);
                
                // Check convergence
                if (i > 10) {
                    const recentTheta0 = path.theta0.slice(-10);
                    const recentTheta1 = path.theta1.slice(-10);
                    
                    const avgChange0 = recentTheta0.reduce((sum, t, idx) => {
                        if (idx === 0) return 0;
                        return sum + Math.abs(t - recentTheta0[idx-1]);
                    }, 0) / 9;
                    
                    const avgChange1 = recentTheta1.reduce((sum, t, idx) => {
                        if (idx === 0) return 0;
                        return sum + Math.abs(t - recentTheta1[idx-1]);
                    }, 0) / 9;
                    
                    if (avgChange0 < 100 && avgChange1 < 1) {
                        break;
                    }
                }
            }
            
            return path;
        }

        // Compare different learning rates
        function compareLearningRates() {
            console.log('Comparing learning rates...');
            
            const learningRates = [0.0000001, 0.0000005, 0.000001, 0.000005];
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00'];
            const traces = [];
            
            learningRates.forEach((lr, index) => {
                const path = simulateWithLearningRate(lr);
                
                const trace = {
                    x: Array.from({length: path.cost.length}, (_, i) => i),
                    y: path.cost,
                    type: 'scatter',
                    mode: 'lines',
                    name: `LR = ${lr.toExponential(1)}`,
                    line: {
                        color: colors[index],
                        width: 3
                    }
                };
                
                traces.push(trace);
            });
            
            const layout = {
                title: 'Cost vs Iterations for Different Learning Rates',
                xaxis: {title: 'Iteration', color: 'white'},
                yaxis: {title: 'Cost', type: 'log', color: 'white'},
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: {color: 'white'},
                legend: {
                    bgcolor: 'rgba(0,0,0,0.5)'
                }
            };
            
            Plotly.newPlot('learningComparisonPlot', traces, layout);
            
            // Also show parameter evolution
            showParameterEvolution(learningRates, colors);
            
            console.log('Learning rate comparison complete');
        }

        // Show how parameters evolve with different learning rates
        function showParameterEvolution(learningRates, colors) {
            const traces = [];
            
            learningRates.forEach((lr, index) => {
                const path = simulateWithLearningRate(lr);
                
                const trace = {
                    x: path.theta0,
                    y: path.theta1,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: `LR = ${lr.toExponential(1)}`,
                    line: {
                        color: colors[index],
                        width: 3
                    },
                    marker: {
                        size: 4,
                        color: colors[index]
                    }
                };
                
                traces.push(trace);
            });
            
            // Add target point
            const targetTrace = {
                x: [50000],
                y: [150],
                type: 'scatter',
                mode: 'markers',
                name: 'Target',
                marker: {
                    size: 15,
                    color: 'red',
                    symbol: 'star'
                }
            };
            
            traces.push(targetTrace);
            
            const layout = {
                title: 'Parameter Space Trajectories',
                xaxis: {title: 'θ₀ (Intercept)', color: 'white'},
                yaxis: {title: 'θ₁ (Slope)', color: 'white'},
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: {color: 'white'},
                legend: {
                    bgcolor: 'rgba(0,0,0,0.5)'
                }
            };
            
            Plotly.newPlot('parameterEvolutionPlot', traces, layout);
        }

        // Simulate gradient descent with specific learning rate
        function simulateWithLearningRate(learningRate) {
            const maxIterations = learningRate > 0.000001 ? 100 : 1000; // Fewer iterations for high LR
            
            let theta0 = 60000;
            let theta1 = 80;
            
            const path = {
                theta0: [theta0],
                theta1: [theta1],
                cost: []
            };
            
            // Calculate initial cost
            let cost = calculateCostAtPoint(theta0, theta1);
            path.cost.push(cost);
            
            for (let i = 0; i < maxIterations; i++) {
                const gradients = calculateGradients(theta0, theta1);
                
                theta0 -= learningRate * gradients.dTheta0;
                theta1 -= learningRate * gradients.dTheta1;
                
                cost = calculateCostAtPoint(theta0, theta1);
                
                path.theta0.push(theta0);
                path.theta1.push(theta1);
                path.cost.push(cost);
                
                // Break if cost explodes (divergence)
                if (!isFinite(cost) || cost > 1e15) {
                    console.log(`Learning rate ${learningRate} caused divergence at iteration ${i}`);
                    break;
                }
            }
            
            return path;
        }

        // Demonstrate overshoot behavior
        function demonstrateOvershoot() {
            console.log('Demonstrating overshoot...');
            
            // Use a high learning rate that causes oscillation
            const highLearningRate = 0.00001;
            const path = simulateWithLearningRate(highLearningRate);
            
            const oscillationTrace = {
                x: Array.from({length: path.cost.length}, (_, i) => i),
                y: path.cost,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'High LR (Overshoot)',
                line: {
                    color: '#ff0000',
                    width: 3
                },
                marker: {
                    size: 4,
                    color: '#ff0000'
                }
            };
            
            // Compare with good learning rate
            const goodPath = simulateWithLearningRate(0.000001);
            const goodTrace = {
                x: Array.from({length: goodPath.cost.length}, (_, i) => i),
                y: goodPath.cost,
                type: 'scatter',
                mode: 'lines',
                name: 'Good LR (Smooth)',
                line: {
                    color: '#00ff00',
                    width: 3
                }
            };
            
            const layout = {
                title: 'Overshoot vs Smooth Convergence',
                xaxis: {title: 'Iteration', color: 'white'},
                yaxis: {title: 'Cost', type: 'log', color: 'white'},
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: {color: 'white'},
                legend: {
                    bgcolor: 'rgba(0,0,0,0.5)'
                }
            };
            
            Plotly.newPlot('learningComparisonPlot', [oscillationTrace, goodTrace], layout);
            
            console.log('Overshoot demonstration complete');
        }

        // Enable interactive mode
        function enableInteractiveMode() {
            console.log('Enabling interactive mode...');
            isInteractiveMode = true;
            
            // Create base plot with cost contours
            const resolution = 30;
            const theta0Range = [35000, 65000];
            const theta1Range = [100, 200];
            
            const contourData = calculateCostSurface(theta0Range, theta1Range, resolution);
            
            const contourTrace = {
                x: contourData.theta0,
                y: contourData.theta1,
                z: contourData.cost,
                type: 'contour',
                colorscale: 'Viridis',
                opacity: 0.7,
                contours: {
                    showlabels: true,
                    labelfont: {color: 'white', size: 10}
                },
                name: 'Cost Contours'
            };
            
            // Add target point
            const targetTrace = {
                x: [50000],
                y: [150],
                type: 'scatter',
                mode: 'markers',
                name: 'Target (True Parameters)',
                marker: {
                    size: 15,
                    color: 'red',
                    symbol: 'star'
                }
            };
            
            const layout = {
                title: 'Interactive Gradient Descent - Click to Start!',
                xaxis: {title: 'θ₀ (Intercept)', color: 'white'},
                yaxis: {title: 'θ₁ (Slope)', color: 'white'},
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: {color: 'white'},
                legend: {
                    bgcolor: 'rgba(0,0,0,0.5)'
                }
            };
            
            Plotly.newPlot('interactivePlot', [contourTrace, targetTrace], layout);
            
            // Add click event listener
            document.getElementById('interactivePlot').on('plotly_click', function(data) {
                if (isInteractiveMode && data.points.length > 0) {
                    const theta0 = data.points[0].x;
                    const theta1 = data.points[0].y;
                    
                    console.log(`Starting gradient descent from: θ₀=${theta0.toFixed(0)}, θ₁=${theta1.toFixed(2)}`);
                    startInteractiveGradientDescent(theta0, theta1);
                }
            });
            
            console.log('Interactive mode enabled - click anywhere on the plot to start gradient descent!');
        }

        // Start gradient descent from clicked point
        async function startInteractiveGradientDescent(startTheta0, startTheta1) {
            const stepSize = parseFloat(document.getElementById('stepSizeSlider').value);
            const speed = parseInt(document.getElementById('speedSlider').value);
            const delay = 1100 - (speed * 100); // Convert speed to delay
            
            // Use adaptive learning rate based on step size
            const learningRate = stepSize * 0.00001;
            
            let theta0 = startTheta0;
            let theta1 = startTheta1;
            
            const pathPoints = {
                theta0: [theta0],
                theta1: [theta1]
            };
            
            // Create starting point marker
            const startTrace = {
                x: [startTheta0],
                y: [startTheta1],
                type: 'scatter',
                mode: 'markers',
                name: 'Starting Point',
                marker: {
                    size: 12,
                    color: 'lime',
                    symbol: 'circle'
                }
            };
            
            Plotly.addTraces('interactivePlot', [startTrace]);
            
            // Animate the descent
            const maxIterations = 100;
            for (let i = 0; i < maxIterations; i++) {
                const gradients = calculateGradients(theta0, theta1);
                
                theta0 -= learningRate * gradients.dTheta0;
                theta1 -= learningRate * gradients.dTheta1;
                
                pathPoints.theta0.push(theta0);
                pathPoints.theta1.push(theta1);
                
                // Update path every few steps
                if (i % 2 === 0) {
                    const pathTrace = {
                        x: pathPoints.theta0,
                        y: pathPoints.theta1,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Descent Path',
                        line: {
                            color: 'cyan',
                            width: 3
                        },
                        marker: {
                            size: 3,
                            color: 'cyan'
                        }
                    };
                    
                    // Update the path trace
                    const currentTraces = document.getElementById('interactivePlot').data;
                    const pathIndex = currentTraces.findIndex(trace => trace.name === 'Descent Path');
                    
                    if (pathIndex >= 0) {
                        Plotly.restyle('interactivePlot', {
                            x: [pathPoints.theta0],
                            y: [pathPoints.theta1]
                        }, pathIndex);
                    } else {
                        Plotly.addTraces('interactivePlot', [pathTrace]);
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
                
                // Check convergence
                if (i > 10) {
                    const recentTheta0 = pathPoints.theta0.slice(-5);
                    const recentTheta1 = pathPoints.theta1.slice(-5);
                    
                    const change0 = Math.abs(recentTheta0[recentTheta0.length-1] - recentTheta0[0]);
                    const change1 = Math.abs(recentTheta1[recentTheta1.length-1] - recentTheta1[0]);
                    
                    if (change0 < 50 && change1 < 0.5) {
                        console.log(`Interactive descent converged at: θ₀=${theta0.toFixed(0)}, θ₁=${theta1.toFixed(2)}`);
                        break;
                    }
                }
            }
            
            // Add final point marker
            const endTrace = {
                x: [theta0],
                y: [theta1],
                type: 'scatter',
                mode: 'markers',
                name: 'Final Point',
                marker: {
                    size: 10,
                    color: 'orange',
                    symbol: 'diamond'
                }
            };
            
            Plotly.addTraces('interactivePlot', [endTrace]);
        }

        // Update step size
        function updateStepSize() {
            const value = document.getElementById('stepSizeSlider').value;
            document.getElementById('stepSizeValue').textContent = value;
        }

        // Update animation speed
        function updateSpeed() {
            const value = document.getElementById('speedSlider').value;
            document.getElementById('speedValue').textContent = value;
            animationSpeed = parseInt(value);
        }

        // Reset the interactive demo
        function resetDemo() {
            console.log('Resetting demo...');
            
            // Clear the plot and restart interactive mode
            enableInteractiveMode();
        }

        // Initialize the first tab
        window.onload = function() {
            console.log('Phase 3 Advanced Visualizations initialized');
            // Auto-generate the cost surface to start
            setTimeout(generateCostSurface, 1000);
        };
    </script>
</body>
</html>